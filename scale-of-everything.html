<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Scale of Everything</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; color: #fff; overflow: hidden; width: 100vw; height: 100vh; font-family: 'IBM Plex Mono', monospace; }
  canvas { position: fixed; top: 0; left: 0; }
  #subtitle-bar { position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%); z-index: 50; text-align: center; pointer-events: none; max-width: 80vw; }
  #subtitle-text { font-family: 'IBM Plex Mono', monospace; font-size: 22px; line-height: 1.6; color: #fff; text-shadow: 0 0 20px rgba(0,0,0,0.95), 0 0 40px #000; background: rgba(0,0,0,0.65); padding: 14px 30px; border-radius: 6px; display: inline-block; opacity: 0; transition: opacity 0.4s ease; }
  #subtitle-text.visible { opacity: 1; }
  #big-number { position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%); z-index: 40; text-align: center; pointer-events: none; opacity: 0; transition: opacity 0.8s ease; }
  #big-number.visible { opacity: 1; }
  #big-number .number { font-family: 'Bebas Neue', sans-serif; font-size: 12vw; letter-spacing: 0.05em; text-shadow: 0 0 80px rgba(100,180,255,0.4); line-height: 1; }
  #big-number .label { font-family: 'IBM Plex Mono', monospace; font-size: 1.5vw; color: rgba(255,255,255,0.6); letter-spacing: 0.3em; text-transform: uppercase; margin-top: 1vh; }
  #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; cursor: pointer; transition: opacity 1s ease; }
  #start-screen.hidden { opacity: 0; pointer-events: none; }
  #start-screen h1 { font-family: 'Bebas Neue', sans-serif; font-size: 6vw; letter-spacing: 0.15em; margin-bottom: 2vh; }
  #start-screen .sub { font-size: 14px; color: #888; letter-spacing: 0.2em; text-transform: uppercase; }
  #start-screen .click { margin-top: 6vh; font-size: 13px; color: #555; letter-spacing: 0.3em; animation: pulse 2s ease-in-out infinite; text-align: center; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
  #debug { position: fixed; top: 10px; left: 10px; font-size: 12px; color: rgba(255,255,100,0.9); z-index: 999; pointer-events: none; white-space: pre-line; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 4px; max-width: 50vw; }
  #test-btn { position: fixed; top: 10px; right: 10px; z-index: 999; background: #222; color: #fff; border: 1px solid #555; padding: 8px 16px; font-family: 'IBM Plex Mono', monospace; font-size: 12px; cursor: pointer; display: none; }
  #test-btn:hover { background: #444; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="start-screen">
  <h1>THE SCALE OF EVERYTHING</h1>
  <div class="sub">A narrated journey through the universe</div>
  <div class="click">CLICK ANYWHERE TO START<br><br><span style="font-size:11px;color:#444">üîä Turn your volume up</span></div>
</div>

<div id="subtitle-bar"><div id="subtitle-text"></div></div>
<div id="big-number"><div class="number" id="bn-number"></div><div class="label" id="bn-label"></div></div>
<div id="debug"></div>
<button id="test-btn" onclick="testVoice()">üîä TEST VOICE</button>

<script>
// ===========================
// CANVAS
// ===========================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, CX, CY;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; CX = W / 2; CY = H / 2; }
window.addEventListener('resize', resize);
resize();

// ===========================
// STARS
// ===========================
const stars = Array.from({length: 900}, () => ({
  x: Math.random(), y: Math.random(), s: 0.3 + Math.random() * 1.8,
  b: 0.2 + Math.random() * 0.8, tw: 1 + Math.random() * 4
}));
function drawStars(t) {
  for (const s of stars) {
    ctx.beginPath(); ctx.arc(s.x * W, s.y * H, s.s, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${s.b * (0.5 + 0.5 * Math.sin(t * s.tw + s.x * 80))})`;
    ctx.fill();
  }
}

// ===========================
// DEBUG LOG
// ===========================
const dbgEl = document.getElementById('debug');
const dbgLines = [];
function dbg(msg) {
  console.log('[TTS]', msg);
  dbgLines.push(msg);
  if (dbgLines.length > 10) dbgLines.shift();
  dbgEl.textContent = dbgLines.join('\n');
}

// ===========================
// TTS - SIMPLE & ROBUST
// ===========================
let allVoices = [];
let pickedVoice = null;

function refreshVoices() {
  allVoices = speechSynthesis.getVoices();
  dbg('Voices available: ' + allVoices.length);
  if (allVoices.length) {
    dbg('First 5: ' + allVoices.slice(0, 5).map(v => v.name).join(', '));
  }
  if (!allVoices.length) return;

  if (!pickedVoice) {
    // Prefer LOCAL system voices (reliable) over Google network voices (flaky)
    const prefs = ['Samantha', 'Daniel', 'Alex', 'Karen', 'Moira', 'Rishi',
      'Microsoft David', 'Microsoft Mark', 'Microsoft Zira',
      'Google UK English Male', 'Google US English'];
    for (const p of prefs) {
      const v = allVoices.find(x => x.name.includes(p));
      if (v) { pickedVoice = v; dbg('Picked voice: ' + v.name); return; }
    }
    // Fallback: any English voice
    pickedVoice = allVoices.find(v => v.lang && v.lang.startsWith('en')) || allVoices[0];
    dbg('Fallback voice: ' + (pickedVoice ? pickedVoice.name : 'NONE'));
  }
}

// Chrome loads voices async
speechSynthesis.onvoiceschanged = refreshVoices;
refreshVoices();

function sayLine(text) {
  return new Promise((resolve) => {
    if (!pickedVoice) refreshVoices();
    if (!pickedVoice) {
      dbg('!! NO VOICE AVAILABLE !!');
      setTimeout(resolve, 2000);
      return;
    }

    const utter = new SpeechSynthesisUtterance(text);
    utter.voice = pickedVoice;
    utter.rate = 0.95;
    utter.pitch = 1.0;
    utter.volume = 1.0;

    let finished = false;
    function done(reason) {
      if (finished) return;
      finished = true;
      dbg('Finished: ' + reason);
      resolve();
    }

    utter.onstart = () => { dbg('‚ñ∂ AUDIO STARTED for: ' + text.substring(0, 30)); };
    utter.onend = () => done('onend');
    utter.onerror = (e) => done('ERROR: ' + (e.error || JSON.stringify(e)));

    dbg('Calling speak()... pending:' + speechSynthesis.pending + ' speaking:' + speechSynthesis.speaking);
    speechSynthesis.speak(utter);

    // Check state right after
    setTimeout(() => {
      dbg('After 500ms ‚Äî speaking:' + speechSynthesis.speaking + ' pending:' + speechSynthesis.pending);
    }, 500);

    // Chrome 14-second bug workaround
    const ticker = text.length > 100 ? setInterval(() => {
      if (!speechSynthesis.speaking) { clearInterval(ticker); return; }
      speechSynthesis.pause(); speechSynthesis.resume();
    }, 12000) : 0;

    utter.onend = () => { if (ticker) clearInterval(ticker); done('onend'); };
    utter.onerror = (e) => { if (ticker) clearInterval(ticker); done('ERROR: ' + (e.error || e)); };

    // Safety net
    setTimeout(() => { if (ticker) clearInterval(ticker); done('timeout'); }, Math.max(5000, text.length * 85));
  });
}

// ===========================
// SUBTITLE & BIG NUMBER
// ===========================
const subEl = document.getElementById('subtitle-text');
function showSub(t) { subEl.textContent = t; subEl.classList.add('visible'); }
function hideSub() { subEl.classList.remove('visible'); }
const bnEl = document.getElementById('big-number');
function showBigNum(n, l) { document.getElementById('bn-number').textContent = n; document.getElementById('bn-label').textContent = l; bnEl.classList.add('visible'); }
function hideBigNum() { bnEl.classList.remove('visible'); }

// ===========================
// DRAWING HELPERS
// ===========================
function drawSun(x, y, r) {
  const g = ctx.createRadialGradient(x, y, 0, x, y, r);
  g.addColorStop(0, '#ffffcc'); g.addColorStop(0.3, '#ffdd44'); g.addColorStop(0.7, '#ff9922'); g.addColorStop(1, '#ff660022');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
  const c = ctx.createRadialGradient(x, y, r * 0.8, x, y, r * 2);
  c.addColorStop(0, '#ffaa2222'); c.addColorStop(1, 'transparent');
  ctx.fillStyle = c; ctx.beginPath(); ctx.arc(x, y, r * 2, 0, Math.PI * 2); ctx.fill();
}

function drawEarth(x, y, r, seed) {
  if (r < 0.5) return;
  const g = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
  g.addColorStop(0, '#6bc5f8'); g.addColorStop(0.5, '#2277bb'); g.addColorStop(1, '#0d3366');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
  if (r > 5) {
    ctx.save(); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.clip();
    for (let i = 0; i < 4; i++) {
      const a = (seed || 0) * 0.001 + i * 1.8;
      ctx.beginPath(); ctx.ellipse(x + Math.cos(a) * r * 0.25, y + Math.sin(a) * r * 0.25, r * 0.35, r * 0.2, a, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(40,140,60,0.3)'; ctx.fill();
    }
    ctx.restore();
  }
}

function drawJupiter(x, y, r) {
  const g = ctx.createRadialGradient(x - r * 0.2, y - r * 0.2, 0, x, y, r);
  g.addColorStop(0, '#f5d5a0'); g.addColorStop(0.5, '#cc8844'); g.addColorStop(1, '#664422');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
  ctx.save(); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.clip();
  for (let i = 0; i < 8; i++) {
    ctx.fillStyle = i % 2 ? 'rgba(180,120,60,0.25)' : 'rgba(140,90,40,0.2)';
    ctx.fillRect(x - r, y - r + (i / 8) * r * 2, r * 2, r * 0.12);
  }
  ctx.beginPath(); ctx.ellipse(x + r * 0.25, y + r * 0.2, r * 0.18, r * 0.1, 0.1, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(200,80,40,0.35)'; ctx.fill(); ctx.restore();
}

function drawSandGlobe(x, y, r, progress, t) {
  if (progress < 0.5) {
    drawEarth(x, y, r, t);
    const crack = progress * 2;
    ctx.strokeStyle = `rgba(200,180,130,${crack})`; ctx.lineWidth = 2 + crack * 3;
    for (let i = 0; i < 8; i++) {
      const a = i * Math.PI / 4;
      ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(a) * r * crack, y + Math.sin(a) * r * crack); ctx.stroke();
    }
  } else {
    const g = ctx.createRadialGradient(x - r * 0.2, y - r * 0.2, 0, x, y, r);
    g.addColorStop(0, '#e8d5a0'); g.addColorStop(0.6, '#c4a560'); g.addColorStop(1, '#8a7040');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
    for (let i = 0; i < 60; i++) {
      const a2 = i * 2.39996, d = r * Math.sqrt(i / 60) * 0.9;
      ctx.beginPath(); ctx.arc(x + Math.cos(a2 + t * 0.0003) * d, y + Math.sin(a2 + t * 0.0003) * d, 1 + Math.random(), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(230,210,160,${(progress - 0.5) * 1})`; ctx.fill();
    }
  }
}

function drawMilkyWay(x, y, r) {
  ctx.save(); ctx.translate(x, y); ctx.rotate(0.3);
  const core = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.25);
  core.addColorStop(0, 'rgba(255,245,220,0.3)'); core.addColorStop(1, 'transparent');
  ctx.fillStyle = core; ctx.beginPath(); ctx.arc(0, 0, r * 0.25, 0, Math.PI * 2); ctx.fill();
  for (let arm = 0; arm < 2; arm++) {
    for (let i = 0; i < 300; i++) {
      const angle = (i / 300) * Math.PI * 3 + arm * Math.PI, dist = (i / 300) * r * 0.9, spread = r * 0.06 * (1 + i / 300);
      ctx.beginPath(); ctx.arc(Math.cos(angle) * dist + Math.sin(i * 7.3) * spread, Math.sin(angle) * dist * 0.35 + Math.cos(i * 5.1) * spread * 0.35, 0.8 + Math.random() * 0.8, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,240,210,${0.35 * (1 - i / 300)})`; ctx.fill();
    }
  }
  ctx.restore();
}

function drawAndromeda(x, y, r) {
  ctx.save(); ctx.translate(x, y); ctx.rotate(-0.5);
  const core = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.3);
  core.addColorStop(0, 'rgba(200,190,255,0.3)'); core.addColorStop(1, 'transparent');
  ctx.fillStyle = core; ctx.beginPath(); ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2); ctx.fill();
  for (let arm = 0; arm < 2; arm++) {
    for (let i = 0; i < 250; i++) {
      const angle = (i / 250) * Math.PI * 2.5 + arm * Math.PI, dist = (i / 250) * r * 0.85, spread = r * 0.05 * (1 + i / 250);
      ctx.beginPath(); ctx.arc(Math.cos(angle) * dist + Math.sin(i * 6.1) * spread, Math.sin(angle) * dist * 0.3 + Math.cos(i * 4.7) * spread * 0.3, 0.6 + Math.random() * 0.6, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,200,255,${0.3 * (1 - i / 250)})`; ctx.fill();
    }
  }
  ctx.restore();
}

function drawObservableUniverse(x, y, r) {
  const web = ctx.createRadialGradient(x, y, 0, x, y, r);
  web.addColorStop(0, 'rgba(150,170,200,0.08)'); web.addColorStop(0.7, 'rgba(100,120,160,0.04)'); web.addColorStop(1, 'transparent');
  ctx.fillStyle = web; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
  for (let i = 0; i < 200; i++) {
    const a = i * 2.39996, d = r * Math.sqrt(i / 200) * 0.95;
    ctx.beginPath(); ctx.arc(x + Math.cos(a) * d, y + Math.sin(a) * d, 0.8, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(180,190,220,${0.25 * (1 - d / r)})`; ctx.fill();
  }
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 2;
  ctx.setLineDash([6, 12]); ctx.stroke(); ctx.setLineDash([]);
}

// ===========================
// SCENES
// ===========================
let SS = {};
const scenes = [
  // 0: Opening question
  {
    lines: ["Question. How many Earths would it take to fill our orbit around the Sun?"],
    init() { SS = {}; },
    draw(t, st) {
      const sunR = 40, orbitR = Math.min(W, H) * 0.35;
      drawSun(CX, CY, sunR);
      ctx.beginPath(); ctx.arc(CX, CY, orbitR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(100,180,255,${0.2 + 0.15 * Math.sin(t * 2)})`;
      ctx.lineWidth = 2; ctx.setLineDash([8, 12]); ctx.stroke(); ctx.setLineDash([]);
      const ea = t * 0.4;
      drawEarth(CX + Math.cos(ea) * orbitR, CY + Math.sin(ea) * orbitR, 18, t * 1000);
      if (st > 2) {
        ctx.fillStyle = `rgba(255,255,255,${Math.min(1, (st - 2) / 1.5) * 0.1})`;
        ctx.font = `${H * 0.5}px "Bebas Neue"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('?', CX, CY); ctx.textBaseline = 'alphabetic';
      }
    }
  },
  // 1: 74,000 Earths
  {
    lines: ["It would take about 74,000 Earths.", "Shoulder to shoulder, packed in tight, all the way around. That's a LOT of Earths."],
    init() { SS = {}; },
    draw(t, st) {
      const sunR = 30, orbitR = Math.min(W, H) * 0.38;
      drawSun(CX, CY, sunR);
      const n = Math.floor(Math.min(1, st / 6) * 600);
      for (let i = 0; i < n; i++) {
        const a = (i / 600) * Math.PI * 2, ex = CX + Math.cos(a) * orbitR, ey = CY + Math.sin(a) * orbitR;
        const g = ctx.createRadialGradient(ex - 1, ey - 1, 0, ex, ey, 3);
        g.addColorStop(0, '#6bc5f8'); g.addColorStop(1, '#1155aa');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(ex, ey, 3, 0, Math.PI * 2); ctx.fill();
      }
      if (st > 1.5) showBigNum('74,000', 'EARTHS'); else hideBigNum();
    }
  },
  // 2: Orbital speed - 200 earths per day
  {
    lines: [
      "Now think about this. Earth orbits the Sun at a hundred and seven thousand kilometers per hour. That's 66 thousand miles per hour.",
      "At that speed, how many of these shoulder-to-shoulder Earths would you fly past in a single day?",
      "Right around 200!"
    ],
    init() { SS = {}; },
    draw(t, st) {
      const earthR = 18, spacing = earthR * 2.4, bandY = CY + 30;
      ctx.beginPath(); ctx.moveTo(-20, bandY + 15); ctx.quadraticCurveTo(CX, bandY - 40, W + 20, bandY + 15);
      ctx.strokeStyle = 'rgba(100,180,255,0.08)'; ctx.lineWidth = earthR * 3; ctx.stroke();
      const scrollSpeed = 50 + Math.min(300, st * 40);
      const offset = (t * scrollSpeed) % spacing;
      for (let i = -2; i < Math.ceil(W / spacing) + 3; i++) {
        let ex = i * spacing - offset;
        if (ex < -earthR * 3 || ex > W + earthR * 3) continue;
        drawEarth(ex, bandY - 25 * Math.sin((ex / W) * Math.PI), earthR, i * 1337);
      }
      if (st > 3) {
        const tY = bandY - 100, tX = CX + Math.sin(t * 0.5) * 30;
        for (let trail = 8; trail >= 0; trail--) {
          ctx.beginPath(); ctx.arc(tX - trail * 18, tY, earthR * 0.7, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(100,200,255,${(1 - trail / 8) * 0.25})`; ctx.fill();
        }
        drawEarth(tX, tY, earthR * 0.7, t * 5000);
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '14px "IBM Plex Mono"'; ctx.textAlign = 'center';
        ctx.fillText('107,000 KM/H  ‚ñ∏  66,000 MPH', CX, tY - earthR - 20);
      }
      if (st > 6) {
        const count = Math.min(200, Math.floor(((st - 6) / 2.5) * 200));
        showBigNum(count.toString(), 'EARTHS PER DAY');
      } else { hideBigNum(); }
    }
  },
  // 3: 7 Jupiters
  {
    lines: ["Or, if you prefer, just 7 Jupiters.", "Jupiter is so massive it really puts Earth to shame."],
    init() { SS = {}; },
    draw(t, st) {
      hideBigNum();
      const sunR = 30, orbitR = Math.min(W, H) * 0.38;
      drawSun(CX, CY, sunR);
      ctx.beginPath(); ctx.arc(CX, CY, orbitR, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(200,150,80,0.12)'; ctx.lineWidth = 2; ctx.setLineDash([8, 12]); ctx.stroke(); ctx.setLineDash([]);
      const jupR = orbitR * Math.PI * 2 / 7 / 2 * 0.85;
      for (let i = 0; i < Math.min(7, Math.floor(st * 1.8) + 1); i++) {
        const angle = (i / 7) * Math.PI * 2 - Math.PI / 2, pop = st - i / 1.8;
        const sc = pop > 0 ? Math.min(1, pop * 3) : 0;
        if (sc > 0) drawJupiter(CX + Math.cos(angle) * orbitR, CY + Math.sin(angle) * orbitR, jupR * sc);
      }
      if (st > 0.5) showBigNum('7', 'JUPITERS');
    }
  },
  // 4: 77 billion school buses
  {
    lines: ["Or, 77 BILLION school buses. Bumper to bumper, all the way around the Sun.", "Can you even imagine that many school buses? I certainly can't."],
    init() { SS = {}; },
    draw(t, st) {
      hideBigNum();
      const sunR = 25, orbitR = Math.min(W, H) * 0.38;
      drawSun(CX, CY, sunR);
      const nb = Math.floor(Math.min(1, st / 5) * 120), bw = (2 * Math.PI * orbitR) / 120;
      for (let i = 0; i < nb; i++) {
        const a = (i / 120) * Math.PI * 2, bx = CX + Math.cos(a) * orbitR, by = CY + Math.sin(a) * orbitR;
        ctx.save(); ctx.translate(bx, by); ctx.rotate(a + Math.PI / 2);
        ctx.fillStyle = '#f5c518'; ctx.fillRect(-bw * 0.4, -bw * 0.15, bw * 0.8, bw * 0.3);
        ctx.fillStyle = '#111'; ctx.fillRect(-bw * 0.25, bw * 0.15, bw * 0.1, bw * 0.1);
        ctx.fillRect(bw * 0.15, bw * 0.15, bw * 0.1, bw * 0.1); ctx.restore();
      }
      if (st > 0.5) showBigNum('77 BILLION', 'SCHOOL BUSES');
    }
  },
  // 5: Turn Earth into sand
  {
    lines: ["But what if we turned the entire Earth into sand.", "Crushed it all down into individual grains."],
    init() { SS = {}; },
    draw(t, st) {
      hideBigNum();
      const r = Math.min(W, H) * 0.22, progress = Math.min(1, st / 6);
      drawSandGlobe(CX, CY, r, progress, t * 1000);
      if (progress > 0.3 && progress < 0.9) {
        for (let i = 0; i < 30 * ((progress - 0.3) / 0.6); i++) {
          const px = CX + (Math.random() - 0.5) * r * 2, py = CY + r + Math.random() * r * ((progress - 0.3) / 0.6);
          ctx.beginPath(); ctx.arc(px, py, 0.5 + Math.random(), 0, Math.PI * 2);
          ctx.fillStyle = `rgba(220,190,130,${0.4 * (1 - py / (CY + r * 2))})`; ctx.fill();
        }
      }
    }
  },
  // 6: 10^31 grains
  {
    lines: ["How many individual grains would there be?", "About ten to the thirty-first power. A mind-bogglingly enormous number."],
    init() { SS = {}; },
    draw(t, st) {
      const r = Math.min(W, H) * 0.18;
      const g = ctx.createRadialGradient(CX - r * 0.2, CY - r * 0.2, 0, CX, CY, r);
      g.addColorStop(0, '#e8d5a0'); g.addColorStop(0.6, '#c4a560'); g.addColorStop(1, '#8a7040');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(CX, CY, r, 0, Math.PI * 2); ctx.fill();
      for (let i = 0; i < 100; i++) {
        const a = i * 2.39996 + t * 0.2, d = r + ((t * 40 + i * 50) % (r * 3));
        ctx.beginPath(); ctx.arc(CX + Math.cos(a) * d, CY + Math.sin(a) * d, 0.8, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(220,190,130,${Math.max(0, 1 - (d - r) / (r * 3)) * 0.5})`; ctx.fill();
      }
      if (st > 1.5) showBigNum('10¬≥¬π', 'GRAINS OF SAND'); else hideBigNum();
    }
  },
  // 7: Each grain ‚Üí Earth, popcorn
  {
    lines: [
      "So what if we turned each grain of sand into an Earth. Watch them pop.",
      "They just keep coming. More and more Earths popping into existence.",
      "This enormous mass of Earths would be roughly three and a half times the size of our entire solar system."
    ],
    init() {
      const pops = [];
      for (let i = 0; i < 350; i++) pops.push({ x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2, popTime: 0.3 + Math.pow(Math.random(), 1.5) * 13, size: 0.4 + Math.random() * 0.6 });
      pops.sort((a, b) => a.popTime - b.popTime);
      for (let i = 0; i < pops.length; i++) { const s = 0.3 + (i / pops.length) * 0.7; pops[i].x *= s; pops[i].y *= s; }
      SS = { pops };
    },
    draw(t, st) {
      hideBigNum();
      const zoom = 1 + Math.pow(Math.max(0, st - 1.5), 2) * 0.12, baseR = Math.min(W, H) * 0.014;
      for (const p of SS.pops) {
        if (st < p.popTime) continue;
        const age = st - p.popTime, sc = Math.min(1, age * 5);
        const bounce = sc < 1 ? sc : 1 + Math.sin(age * 10) * 0.08 * Math.exp(-age * 2);
        const r = baseR * p.size * bounce / Math.pow(zoom, 0.5);
        const ex = CX + p.x * (W * 0.42) / Math.pow(zoom, 0.5), ey = CY + p.y * (H * 0.42) / Math.pow(zoom, 0.5);
        if (r > 0.5) drawEarth(ex, ey, r, p.popTime * 1000);
        if (age < 0.25) {
          ctx.beginPath(); ctx.arc(ex, ey, r * 4 * (1 - age / 0.25), 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,200,${(1 - age / 0.25) * 0.4})`; ctx.fill();
        }
      }
      if (st > 10) {
        const ssR = Math.min(W, H) * 0.08 / Math.pow(zoom, 0.5);
        ctx.beginPath(); ctx.arc(CX, CY, ssR, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(100,150,255,0.2)'; ctx.lineWidth = 1; ctx.setLineDash([4, 6]); ctx.stroke(); ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(100,150,255,0.3)'; ctx.font = '11px "IBM Plex Mono"'; ctx.textAlign = 'center';
        ctx.fillText('‚Üê Solar System ‚Üí', CX, CY + ssR + 16);
      }
    }
  },
  // 8: Line them up ‚Äî galaxy sized?
  {
    lines: ["But what if we lined all of these Earths up, shoulder to shoulder, in one enormous orbit.", "How big would that orbit be? Would it be as big as a galaxy?"],
    init() { SS = {}; },
    draw(t, st) {
      hideBigNum();
      const gR = Math.min(W, H) * 0.25;
      drawMilkyWay(CX, CY, gR);
      const frac = Math.min(1, st / 7), oR = gR * 0.3 + frac * gR * 0.8;
      for (let i = 0; i < Math.floor(frac * 400); i++) {
        const a = (i / 400) * Math.PI * 2;
        ctx.beginPath(); ctx.arc(CX + Math.cos(a) * oR, CY + Math.sin(a) * oR, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100,180,255,0.6)'; ctx.fill();
      }
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.font = '11px "IBM Plex Mono"'; ctx.textAlign = 'center';
      ctx.fillText('MILKY WAY', CX, CY + gR + 25);
    }
  },
  // 9: Past Andromeda
  {
    lines: ["Would it reach the Andromeda galaxy, our nearest neighbor?", "It would blow right past it. Not even close."],
    init() { SS = {}; },
    draw(t, st) {
      hideBigNum();
      const mwR = Math.min(W, H) * 0.12, aR = mwR * 0.9, sep = Math.min(W, H) * 0.2;
      drawMilkyWay(CX - sep * 0.5, CY, mwR);
      drawAndromeda(CX + sep * 0.5, CY, aR);
      ctx.fillStyle = 'rgba(255,255,255,0.25)'; ctx.font = '10px "IBM Plex Mono"'; ctx.textAlign = 'center';
      ctx.fillText('MILKY WAY', CX - sep * 0.5, CY + mwR + 18);
      ctx.fillText('ANDROMEDA', CX + sep * 0.5, CY + aR + 18);
      const oR = sep * 0.3 + Math.min(1, st / 5) * Math.min(W, H) * 0.45;
      ctx.beginPath(); ctx.arc(CX, CY, oR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(100,180,255,${0.3 + 0.2 * Math.sin(t * 2)})`; ctx.lineWidth = 3; ctx.stroke();
      if (st > 3) {
        ctx.fillStyle = 'rgba(100,180,255,0.5)'; ctx.font = '12px "IBM Plex Mono"'; ctx.textAlign = 'center';
        ctx.fillText('ORBIT OF EARTHS', CX, CY - oR - 12);
        ctx.fillText('(STILL GROWING...)', CX, CY - oR + 2);
      }
    }
  },
  // 10: 45 BILLION light years
  {
    lines: [
      "No. It would be a staggering 45 BILLION light years across!",
      "That is BIGGER than the observable universe itself!",
      "All from turning Earth into sand, and each grain back into an Earth."
    ],
    init() { SS = {}; },
    draw(t, st) {
      const uR = Math.min(W, H) * 0.2;
      drawObservableUniverse(CX, CY, uR);
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.font = '11px "IBM Plex Mono"'; ctx.textAlign = 'center';
      ctx.fillText('OBSERVABLE UNIVERSE', CX, CY + uR + 20);
      ctx.fillText('93 billion light-years', CX, CY + uR + 36);
      const frac = Math.min(1, st / 8), oR = uR * 0.5 + frac * uR * 0.85;
      for (let i = 0; i < Math.floor(frac * 500); i++) {
        const a = (i / 500) * Math.PI * 2;
        ctx.beginPath(); ctx.arc(CX + Math.cos(a) * oR, CY + Math.sin(a) * oR, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100,200,255,0.5)'; ctx.fill();
      }
      ctx.beginPath(); ctx.arc(CX, CY, oR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(80,180,255,${0.15 + 0.1 * Math.sin(t * 1.5)})`; ctx.lineWidth = 6; ctx.stroke();
      if (st > 3) showBigNum('45 BILLION', 'LIGHT-YEARS ACROSS');
      if (st > 8) {
        ctx.fillStyle = `rgba(255,100,100,${Math.min(1, (st - 8) / 2) * 0.7})`;
        ctx.font = `bold ${Math.floor(W * 0.022)}px "IBM Plex Mono"`; ctx.textAlign = 'center';
        ctx.fillText('BIGGER THAN THE OBSERVABLE UNIVERSE', CX, CY + uR + 65);
      }
    }
  },
  // 11: Closing
  {
    lines: ["And it all started with a single pale blue dot."],
    init() { SS = {}; },
    draw(t, st) {
      hideBigNum();
      const r = 8 + 4 * Math.sin(t * 0.8);
      drawEarth(CX, CY, r, t * 1000);
      const glow = ctx.createRadialGradient(CX, CY, r, CX, CY, r * 8);
      glow.addColorStop(0, 'rgba(100,180,255,0.15)'); glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(CX, CY, r * 8, 0, Math.PI * 2); ctx.fill();
      if (st > 3) {
        ctx.fillStyle = `rgba(255,255,255,${Math.min(1, (st - 3) / 2) * 0.5})`;
        ctx.font = `${Math.floor(W * 0.025)}px "Bebas Neue"`; ctx.textAlign = 'center';
        ctx.fillText('THE SCALE OF EVERYTHING', CX, CY + 70);
      }
    }
  }
];

// ===========================
// SCENE RUNNER
// ===========================
let sceneIndex = -1, sceneTime = 0, sceneActive = false;

async function runScene(idx) {
  if (idx >= scenes.length) { hideSub(); hideBigNum(); dbg('ALL SCENES DONE'); return; }

  sceneIndex = idx;
  sceneTime = 0;
  sceneActive = true;
  const scene = scenes[idx];
  if (scene.init) scene.init();

  dbg('Scene ' + idx);

  // Speak each line ‚Äî subtitle shows simultaneously with voice
  for (const line of scene.lines) {
    showSub(line);
    await sayLine(line);
    await wait(0.15);
  }

  await wait(0.5);
  hideSub();
  hideBigNum();
  await wait(0.3);
  runScene(idx + 1);
}

function wait(s) { return new Promise(r => setTimeout(r, s * 1000)); }

// ===========================
// RENDER
// ===========================
let lastFrame = 0;
function render(ts) {
  requestAnimationFrame(render);
  const dt = lastFrame ? (ts - lastFrame) / 1000 : 0;
  lastFrame = ts;
  const t = ts / 1000;
  if (sceneActive) sceneTime += dt;
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
  drawStars(t);
  if (sceneIndex >= 0 && sceneIndex < scenes.length) scenes[sceneIndex].draw(t, sceneTime, dt);
}
requestAnimationFrame(render);

// ===========================
// TEST VOICE BUTTON
// ===========================
function testVoice() {
  refreshVoices();
  dbg('TEST: voices=' + allVoices.length + ' picked=' + (pickedVoice ? pickedVoice.name : 'NONE'));

  // DON'T call cancel() ‚Äî it puts Chrome in a zombie state

  const test = new SpeechSynthesisUtterance('Testing. One two three.');
  if (pickedVoice) test.voice = pickedVoice;
  test.rate = 1;
  test.volume = 1;
  test.onstart = () => dbg('TEST ‚ñ∂ started');
  test.onend = () => dbg('TEST ‚úì ended');
  test.onerror = (e) => dbg('TEST ‚úó error: ' + e.error);

  speechSynthesis.speak(test);

  setTimeout(() => {
    dbg('TEST state ‚Äî speaking:' + speechSynthesis.speaking + ' pending:' + speechSynthesis.pending);
  }, 300);
}

// ===========================
// START
// ===========================
document.getElementById('start-screen').addEventListener('click', async function() {
  this.classList.add('hidden');
  document.getElementById('test-btn').style.display = 'block';
  refreshVoices();
  // Wait a beat for voices to load, then just go. No warmup, no cancel.
  await wait(0.3);
  refreshVoices();
  dbg('Starting. Voice: ' + (pickedVoice ? pickedVoice.name : 'NONE'));
  dbg('speechSynthesis exists: ' + !!window.speechSynthesis);
  dbg('Voices count: ' + speechSynthesis.getVoices().length);
  dbg('Browser: ' + navigator.userAgent.split(') ').pop());
  runScene(0);
});
</script>
</body>
</html>
